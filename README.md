### Библиотека работы с вещественными матрицами

#### Опись имущества:

1. `class D2DoubleMatrix`: содержит представление двумерной
вещественной матрицы
    1. `D2DoubleMatrix.getEntryArray()` возвращает
    `DoubleArray()`, в котором содержатся все
       элементы матрицы, вытянутые в линию строчка за строчкой
       
    2. `D2DoubleMatrix.shape()` возвращает пару `Pair<Int, Int>`,
    где `Pair.first` количество строк матрицы, 
       `Pair.second` количество столбцов
       
    3. `D2DoubleMatrix.numberAt(r: Int, c: Int)` элемент
    в строке `r` и столбце `c`
       
    4. `D2DoubleMatrix.setAt(r: Int, c: Int, val: Double)` установка
    значения в строке `r` столбце `c`
       
    5. `D2DoubleMatrix.toString()` красивый вывод прилагается! (совсем красивый вывод ещё надо доработать,
       чтобы точки были под дочками, запятые под запятыми)
    
    6. `==` сравнивает матрицы на равенство с точностью до `1e-10`
       (может быть не самое лучшее решение)
       
    7. `*`, `-`, `+`. Также есть умножение на скаляр справа.

2. `abstract class MatrixCreator` содержит фабричные методы создния матриц
    1. `fromRows(vararg rows: DoubleArray)` создает матицу из последовательности строк
    
    2. `zero(row: Int, column: Int)` матрица, заполненная нулями, в которой 
    `row` строк `column` столбцов
       
    3. `randomElementUniformMatrix(row: Int, column: Int, leftBound: Double, rightBound: Double)` матрица формы
    `(row, column)`, каждый элемент которой случайня величина равонмерно распределенная на `[leftBound, rightBound]`
       
    4. `clone(A: D2DoubleMatrix)` возвращает копию матрицы
    
    5. `transpose(A: D2DoubleMatrix)` возвращает транспонированную матрицу
    
    6. `fromFlatArray(row: Int, column: Int, arr: DoubleArray)` создает матрицу формы `(row, column)`из плоского 
    массива. Должно быть выполнено `arr.size() == row * column`
       
    7. `embed(A: D2DoubleMatrix, rows: Int, columns: Int)` вкладывает матрицу в левый верхний угол
    большей нулевой матрицы.
       
    8. `fun slice(A: D2DoubleMatrix,
       fromRowInclusive: Int,
       toRowExclusive: Int,
       fromColumnInclusive: Int,
       toColumnExclusive: Int
       )` вырезает из матрицы подматрицу
    
3. `interface multiplyStrategy` общий класс для всех алгоритмов умножния матрицы
на матрицу. Далее перечислены реализации:
   
    1. `DummyMultiplier` обычное умножение двух матриц по определению
    
    2. `DummyCacheFriendly` то же что и обычное, но старается бегать 
    по подряд идущим элементам массивов.
       
    3. `Strassen` реализация алгоритма Штрассена. Параметры внутри класса, которые можно было бы настраивать, если бы
       я не объявил их приватными:
        1. `private strassenThreshold = 50`. Если хоть одна размерность перемножаемых матриц становиться меньше этого значения,
        алгоритм переключается на `defaultMultiplier`
           
        2. `private defaultMultiplier` какой-то алгоритм, асимптотически худший, чем алгоритм Штрассена,
        но в котором константа лучше
       
    4. `SmallMatrixMultiplier` класс, чтобы умножать маленькие матрицы.
    Сам выбирает, что надо использовать: `DummyMultiplier` или `DummyCacheFriendly` 
       
    Сравнительная таблица скорости различных `multiplyStrategy` (тесты проведены на моей локальной
   машине):
    
    |Mat(m, n) x Mat(n, k)|`DummyMultiplier`|`DummyCacheFriendly`|`Strassen`|
    |---------------------|-----------------|--------------------|----------|
    |(1026, 1026)x(1026, 1026)|32 s         | 32 s               |9 s       |
    |(100, 100000)x(100000, 100)|40 s       |20 s                |20 s      |

    таблица носит не столько научный, сколько утешительный для меня характер,
    что я не зря писал разные реализации
   
    
    

5. `user.kt` примеры кода

6. в разделе `src/test` можно найти некоторые (достаточно скудные) юнит тесты

#### Примеры использования

```kotlin
fun main() {
    val mt1 = MatrixCreator.fromRows(doubleArrayOf(1.0, 2.0, 3.0, 4.0, 5.0, 6.0))
    val mt2 = MatrixCreator.transpose(mt1)
    println(mt1)
    /*
    *[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]]
    */
    println(mt2)
    /*
    * [[1.0],
    *  [2.0],
    *  [3.0],
    *  [4.0],
    *  [5.0],
    *  [6.0]]
    */
    println(mt1 * mt2)
    /*
    * [[91.0]]
    */
    println(mt2 * mt1)
    /*
    * [[1.0, 2.0, 3.0, 4.0, 5.0, 6.0],
    *  [2.0, 4.0, 6.0, 8.0, 10.0, 12.0],
    *  [3.0, 6.0, 9.0, 12.0, 15.0, 18.0],
    *  [4.0, 8.0, 12.0, 16.0, 20.0, 24.0],
    *  [5.0, 10.0, 15.0, 20.0, 25.0, 30.0],
    *  [6.0, 12.0, 18.0, 24.0, 30.0, 36.0]]
    */
    println(mt2 * mt1 * mt2)
    /*
    * [[91.0],
    * [182.0],
    * [273.0],
    * [364.0],
    * [455.0],
    * [546.0]]
    */
    
}
```